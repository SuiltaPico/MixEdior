# 项目架构设计

本项目采用基于 **Turborepo + pnpm workspace** 的 **monorepo** 方式进行管理，以解决多包依赖问题。项目主要分为三个核心目录：`packages`、`apps` 和 `plugins`。

- **`packages`**: 存放核心的代码包，每个包可单独发布和使用。这些包提供了编辑器的基础功能和通用组件。
- **`apps`**: 存放应用级的项目，例如 MixEditor 的文档、在线演示环境等。这些应用依赖于 `packages` 中的核心包构建。
- **`plugins`**: 存放插件，插件用于扩展编辑器的功能。

此外，`docs` 文件夹用于存放项目的所有文档，包括设计文档、API 文档、使用教程等。

**目录结构概览：**

```
mixeditor/
├── apps/
│   ├── docs/         # MixEditor 文档站点
│   └── playground/   # MixEditor 在线演练场
├── packages/
│   ├── core/         # 编辑器核心逻辑 (@mixeditor/core)
│   ├── browser-view/ # 浏览器渲染层 (@mixeditor/browser-view)
│   └── ...           # 其他核心包
├── plugins/
│   ├── plugin-a/     # 插件 A (@mixeditor/plugin-a)
│   ├── plugin-b/     # 插件 B (@mixeditor/plugin-b)
│   └── ...           # 其他插件
├── docs/             # 项目文档
│   ├── design.md     # 设计文档
│   ├── api.md        # API 文档
│   └── ...
├── scripts/      # 构建/部署脚本
└── tests/        # 测试目录
```
# 项目目标
构建一个可扩展的编辑器，通过插件化架构实现功能无限扩展。核心仅提供最基础的抽象和协作机制，所有复杂功能（如富文本格式、表格、协同编辑）均由插件实现。

# 步骤
## 1. 设计核心架构
本节讲述 `@mixeditor/core` 的设计。
### 核心思路
#### 行为处理器表
为了便于定义和扩展功能，我们使用行为处理器表来管理节点和操作的行为。

节点和操作的管理器都有一个行为处理器表。处理器表是个路由表，可以根据节点类型和行为类型确定一个行为处理器，并在缺失行为处理器时，使用该行为的默认行为处理器。

插件可以注册提供更多的行为类型，也可以注册某个节点针对某个行为的行为处理器，还可以替换默认的行为处理器。

例如：`@mixeditor/browser-view` 为 `NodeManager` 注册了 `bv:get_child_pos` 行为类型。而 `@mixeditor/plugin-basic-text` 插件为 `Text` 节点添加了 `bv:get_child_pos` 的行为处理器。

#### 责任链
为了便于控制节点中消息的传播，我们使用责任链模式。插件可以注册自己的责任链、替换默认的责任链。

责任链的执行流程如下：执行器会调用节点特定的行为处理器以发送消息，并等待节点返回的结果，再根据结果决定执行器如何继续执行责任链或是执行责任链结束流程。

### 核心服务层设计
#### 节点管理系统
`Node`（节点）是内容单元，记录自身的类型和状态。`Node` 对外界采用黑盒模式，只能通过在 `NodeManager` 上注册的行为处理器表才能操纵节点。

为了唯一标识节点，`Node` 拥有一个 `id` 属性。

`NodeManager` 是节点的管理器，负责管理如下内容：
* 储存和提供节点行为处理器。节点行为处理器定义了某种类型的节点的特定行为。
  * 初始行为：
    * `get_child`：获取子节点。
    * `get_children_count`：获取子节点数量。
    * `save`：保存节点。
    * `slice`：切片节点。
    * `move_enter`：移动节点。
* 生成节点 id。给节点生成一个全局唯一的 ULID。
#### 操作管理系统
该系统的目标是为了实现可逆的编辑操作追踪。

`Operation`（操作）是编辑器节点树可跟踪的变更记录，记录了自身的 id、类型、数据等元信息。

`OperationManager` 是操作的管理器，负责管理如下内容：
* 储存和提供操作行为处理器。操作行为处理器定义了某种类型的操作的特定行为，例如插入文本操作的 `execute` 和 `undo`（执行和撤销） 行为。
  * 初始行为：
    * `execute`：执行操作。
    * `undo`：撤销操作。
    * `cancel`：取消操作。
* 生成操作 id。给操作生成一个全局唯一的 ULID。

`HistoryManager` 是操作历史的管理器，负责跟踪历史记录，提供执行、撤销和取消等多种行为。另外还提供事务支持，可以在执行批量操作出错时自动回滚。

发生操作冲突时，`HistoryManager` 会回退到各个冲突方一致的版本，然后重新按顺序（由操作的时间戳、用户id决定）执行一次操作。
#### 事件传播系统
该系统的目标是为了实现建立灵活的事件响应机制。事件是广播式传播（非DOM事件模型）。而责任链由事件处理器自己实现。

因为一些事件处理器是异步的，所以事件传播系统需要提供异步支持。

`Event`（事件）描述了一次通知的内容，记录了自身的类型、内容和上下文。

`EventManager` 是事件的管理器，负责管理如下内容：
* 储存和触发事件处理器。为了方便插件定义事件处理器的优先级，事件基于锚点链来确保执行顺序。事件会在前置锚点完成之后触发，自己完成后会通知后置锚点。插件为事件处理器连接锚点时会有回环检测，以确保事件处理器的触发不会产生无限循环。

#### 选区管理模型
用户对节点的更改围绕着选区而进行。
`Selection`（选区）记录 `Selected`（选区信息）。

`Selected` 记录选区类型、选区范围等信息，共有两种选区类型：
* `CollapsedSelected`：折叠选择，仅选择一个节点。
* `ExtendedSelected`：扩展选择，选择了以两个节点为界之间的所有节点。

#### 持久化系统
`Saver`（保存器）负责管理以下内容：
* 储存和提供加载器。加载器用于将 `TransferDataObject` 转换为 `Node`。
* 提供加载和保存接口。提供 `TransferDataObject` 和  `Node` 双向转换的接口。
* 储存和提供序列化和反序列化器。序列化和反序列化器用于将 `TransferDataObject` 和持久化数据（如JSON、HTML）相互转换。

`TransferDataObject`（传输对象）是一个接口，是用于持久化的中间格式，要求目标是个 JS 对象且具有 `type` 键。每个节点都应该有其对应的传输对象。

```
┌───────────┐       ┌───────────────────┐       ┌───────────┐
│  Node树   │<----->│ TransferDataObject │<----->│ 持久化数据 │
└───────────┘       └───────────────────┘       └───────────┘
     ▲                      ▲                         ▲
     │ 节点序列化             │ 格式转换                 │ 存储介质适配
     └──────────────────────┴─────────────────────────┘
```

如果在持久化处理中出现错误，会按照参数的容错选项决定是忽略错误，跳过当前对象的转换，还是直接抛出错误。

### 整体流程
#### 删除流程
```
删除操作触发（Backspace/Delete 键）
├─ [浏览器视图层] 捕获键盘事件
│   └─ handle_key_down 处理器
│       ├─ 监听 keydown 事件
│       ├─ 判断 Backspace/Delete 键
│       └─ 创建对应方向的 DeleteSelectedEvent
│           └─ 通过 editor.event_manager.emit() 发送事件
├─ [核心事件层] 判断选区类型
│   ├─ 折叠选区（单个光标点）
│   │   └─ 执行 execute_delete_from_point 责任链
│   │       ├─ 当前节点处理 handle_delete_from_point
│   │       │   ├─ Text 节点处理
│   │       │   │   ├─ 前向删除（Backspace）
│   │       │   │   │   ├─ 位置 <=0 → Skip（转父节点处理）
│   │       │   │   │   ├─ 文本长度=1 → DeleteSelf（删除自身）
│   │       │   │   │   └─ 正常 → 创建删除操作并调整光标
│   │       │   │   └─ 后向删除（Delete）
│   │       │   │       ├─ 位置 >=长度 → Skip
│   │       │   │       ├─ 文本长度=1 → DeleteSelf
│   │       │   │       └─ 正常 → 创建删除操作
│   │       │   └─ Paragraph 节点处理
│   │       │       ├─ 前向删除 → 进入前一个子节点（EnterChild）
│   │       │       │   └─ 递归处理子节点的删除逻辑
│   │       │       └─ 后向删除 → 进入后一个子节点（EnterChild）
│   │       │           └─ 递归处理子节点的删除逻辑
│   │       ├─ 处理决策结果
│   │       │   ├─ DeleteSelf → 通知父节点删除自己
│   │       │   │   └─ 创建父节点的 DeleteChildrenOperation
│   │       │   ├─ Skip → 转父节点处理
│   │       │   │   └─ 递归处理父节点的删除逻辑
│   │       │   └─ EnterChild → 进入子节点处理
│   │       │       └─ 递归到子节点的最大/最小位置处理
│   │       └─ 递归处理直到完成
│   └─ 扩展选区（范围选择）
│       └─ 执行 execute_delete_range 责任链
│           ├─ 处理相同节点范围
│           │   └─ 调用节点 handle_delete_range
│           │       ├─ Text 节点
│           │       │   ├─ 全选（from<=0 && to>=长度）→ DeleteSelf
│           │       │   └─ 部分删除 → 创建 DeleteRangeOperation
│           │       └─ Paragraph 节点
│           │           ├─ 全选子节点 → DeleteSelf
│           │           └─ 部分删除 → 创建 DeleteChildrenOperation
│           ├─ 处理跨节点范围
│           │   ├─ 查找公共祖先（get_common_ancestor_from_node）
│           │   ├─ 分解为三个处理段
│           │   │   ├─ 起始节点到祖先路径
│           │   │   │   └─ 从起始节点向上处理到公共祖先
│           │   │   ├─ 结束节点到祖先路径
│           │   │   │   └─ 从结束节点向上处理到公共祖先 
│           │   │   └─ 公共祖先内部范围
│           │   │       └─ 处理祖先节点内的剩余范围
│           │   └─ 各段分别执行 handle_delete_range
│           │       └─ 递归处理直到公共祖先
│           └─ 合并相邻节点（execute_merge_node）
│               ├─ 父子关系合并
│               │   ├─ 前节点合并到父节点
│               │   │   └─ 通过 insert_children 合并内容
│               │   └─ 后节点合并到父节点
│               │       └─ 通过 insert_children 合并内容
│               └─ 非父子关系合并
│                   └─ 查找公共祖先逐层合并
│                       ├─ 通过 get_common_ancestor_from_node 查找
│                       └─ 从底层向上尝试合并直到拒绝
├─ 生成操作记录
│   ├─ 创建批量操作（BatchOperation）
│   │   └─ 收集所有子操作：
│   │       ├─ DeleteRangeOperation
│   │       ├─ DeleteChildrenOperation
│   │       └─ InsertChildrenOperation（合并时产生）
│   └─ 记录到历史管理器（history_manager.execute）
└─ 更新选区状态
    ├─ 折叠选区 → 调整光标位置
    │   ├─ 根据操作结果设置 new_selected
    │   └─ 无新位置时保持原选区起点
    └─ 扩展选区 → 清除选区
        └─ 执行 collapsed_select 重置为起点
```

#### 事件、操作和节点的关系
事件触发事件处理器，事件处理器通常是一个责任链处理函数，它会逐个节点调用节点处理器以查找待处理的节点，而节点处理器产生和执行操作。

例如：用户触发了输入文本事件，输入文本事件的监听器包含寻找处理输入文本事件节点的责任链，查找成功后，节点的责任链处理器将输入文本操作在 `HistoryManager` 上推送并执行。


## 2. 设计浏览器视图架构
本节讲述 `@mixeditor/browser-view` 的设计。
### 结构
`NodeRendererManager` 管理节点渲染相关的功能，具体为如下内容：
* 储存和提供节点渲染器。节点渲染器应当返回一个 DOM Node，如果节点渲染器有子节点，应当调用 `NodeRendererWrapper` 进行渲染。

`NodeRendererWrapper` 是带缓存的节点渲染器调用器。它会缓存节点初次渲染产生的 DOM Node，在后续的重复渲染中使用缓存以节省渲染开销。插件应该保证节点更新后能立即更新 DOM Node。

`EditorRenderer` 是编辑器的渲染入口层，负责充当事件总线和渲染 `ContentRenderer`、`SelectionRenderer`。
* `ContentRenderer` 负责渲染内容，从根节点（Document）开始渲染。
* `SelectionRenderer` 负责渲染选区。
### 渲染方案
鉴于 SolidJS 对 DOM 高效率渲染、更新和事件处理的性能表现，浏览器视图使用 SolidJS 进行 DOM 渲染。

### 注册的接口
#### 枚举
* `PointerEventResult`：鼠标事件的结果。
  * `skip`：跳过。
  * `handled`：已处理。
#### 扩展 `NodeManager`
`@mixeditor/browser-view` 为 `NodeManager` 添加了这些行为类型：
* `bv:handle_pointer_down`：处理鼠标按下事件。返回值为 `PointerEventResult` 枚举值。
* `bv:handle_pointer_up`：处理鼠标释放事件。返回值为 `PointerEventResult` 枚举值。
* `bv:handle_key_down`：处理键盘按下事件。返回值为 `PointerEventResult` 枚举值。
* `bv:get_child_pos`：获取子节点的位置。

## 3. 设计基础文本插件
本节讲述 `@mixeditor/plugin-basic-text` 的设计。

### 插件结构
`@mixeditor/plugin-basic-text` 插件提供两个节点类型：
* `Text` 是文本节点，记录自身的文本内容。
* `Paragraph` 是段落节点，记录一系列的节点。


### 节点
#### 文本节点
`Text` 是文本节点，记录自身的文本内容。

插件为 `Text` 节点添加了这些行为处理器：
* `bv:pointer_down`：在点击时更改选区为折叠选区，并选中点击的文本。


## 4. 稳定核心架构
通过 core、browser-view、plugin-basic-text、plugin-text-style 插件的组合，做出最小可用成品。

未解决的问题：
* 扩展选区的渲染（节点）。
* 输入文本的责任链。输入文本时，应当触发文本输入事件。事件管理器调用文本输入处理的责任链，责任链应当从当前选区的节点开始：
  * 如果选区是折叠选区，则从选区的节点开始。
  * 如果选区是扩展选区，则从选区的起始节点开始。并先删除选区范围内的节点或内容。

  不断按照责任链查找，直到找到待处理的节点。

* 光标的左右移动。按下键盘左右箭头键时，应当触发光标移动事件。事件管理器调用光标移动处理的责任链，责任链应当从当前选区的节点开始：
  * 如果选区是折叠选区，则从选区的节点开始。
  * 如果选区是扩展选区，则从选区的起始节点开始。

  不断按照责任链查找，直到找到待处理的节点。

# 思考
## 1. 节点为什么需要 `id` 属性？
节点需要 `id` 属性，是因为节点需要被唯一标识。同时，在编辑器的内存中可以构造一个映射表，将 `id` 映射为节点，以加快节点查找速度。

我们可以探讨一下，如果节点没有 `id` 属性，那么节点应该如何被唯一标识？
* 如果仅使用节点在树中的位置来标识节点，那么当节点在树中的位置发生变化时，节点的标识也会发生变化。路径作为 ID 的形式只适合在节点树不变的场景下使用。

* 如果仅使用节点的指针来标识节点，那么难以进行跨主机的协作编辑。

因此，节点还是需要一个全局唯一的独立标识，以支持稳定的引用。


